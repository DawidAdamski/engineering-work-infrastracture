# Qdrant

Qdrant is a **vector database** used for storing and retrieving customer embeddings generated by the n8n workflow.  
It enables **AI-based segmentation and similarity search** across CRM customers.

---

## Purpose

- Store numerical embeddings representing customer profiles.  
- Support similarity queries (find customers with comparable purchase behaviors).  
- Serve as the **AI-driven extension** to classical RFM segmentation.  
- Integrate seamlessly with PostgreSQL and CRM API inside Kubernetes.

---

## Deployment Overview

|Item|Value|
|:--|:--|
|**Namespace**|`crm-rfm`|
|**Service name**|`qdrant`|
|**Port**|`6333`|
|**Persistence**|PVC mounted to `/qdrant/storage`|
|**Access**|Internal ClusterIP service|

Internal DNS for in-cluster communication:
qdrant.crm-rfm.svc.cluster.local:6333


Qdrant runs as a **Deployment** or **StatefulSet** depending on storage configuration.  
Data is persisted using a PersistentVolumeClaim (PVC).

---

## Collection Design

|Parameter|Example|
|:--|:--|
|**Collection name**|`customers`|
|**Vector size**|`1536` (for `text-embedding-3-large` model)|
|**Distance metric**|`Cosine`|
|**Payload fields**|`customer_id`, `created_at`, `segment`, `rfm_score`|

The **n8n workflow** automatically ensures that the collection exists before inserting data.

Example initialization request (via HTTP API):

```json
PUT /collections/customers
{
  "vectors": {
    "size": 1536,
    "distance": "Cosine"
  }
}
```

---

## Typical Data Flow

1. n8n fetches customers from PostgreSQL without embeddings.
2. n8n calls the OpenAI Embedding API to generate a vector.
3. n8n sends the vector and metadata to Qdrant:

```json
POST /collections/customers/points
{
  "points": [
    {
      "id": 123,
      "vector": [0.011, 0.092, -0.034, ...],
      "payload": {
        "customer_id": 123,
        "rfm_recency": 45,
        "rfm_frequency": 5,
        "rfm_monetary": 1200.5
      }
    }
  ]
}
```

4. Qdrant indexes and stores the point, making it available for similarity search.

---

## Querying Similar Customers

CRM API can query Qdrant to find customers with similar embeddings:

```json
POST /collections/customers/points/search
{
  "vector": [0.011, 0.092, -0.034, ...],
  "limit": 5,
  "with_payload": true
}
```

Response example:

```json
{
  "result": [
    { "id": 789, "score": 0.91, "payload": { "customer_id": 789 } },
    { "id": 654, "score": 0.87, "payload": { "customer_id": 654 } }
  ]
}
```

---

## Integration with Other Components

| Component | Interaction |
|:--|:--|
| n8n workflow | Creates or updates points in Qdrant using embeddings from OpenAI. |
| CRM API | Reads vectors and performs similarity queries for segmentation or recommendations. |
| PostgreSQL | Indirect relationship — Qdrant stores references to PostgreSQL customer IDs. |

---

## Configuration Variables

| Variable | Purpose |
|:--|:--|
| `QDRANT_URL` | Internal URL for the service (default: `http://qdrant.crm-rfm.svc.cluster.local:6333`) |
| `QDRANT_COLLECTION` | Collection name used by n8n and CRM API (`customers`) |
| `QDRANT_API_KEY` | Optional — if authentication is enabled |

---

## Persistence Notes

- Use a PVC to persist vectors between Pod restarts.
- Default path: `/qdrant/storage` inside the container.
- Storage requirements grow with dataset size and vector dimension.
- For development in Minikube, a PVC volume is sufficient.

---

## Security & Access

- Default deployment exposes only port `6333` (HTTP API).
- Limit external exposure — Qdrant should remain an internal ClusterIP service.
- Secure credentials and configuration using Kubernetes Secrets or ConfigMaps.

---

## Example Use Case in Thesis

In the engineering work, Qdrant serves as the AI-based segmentation engine, allowing comparison between:

- Traditional SQL-driven segmentation (RFM table in PostgreSQL), and
- AI-driven similarity search (vector embeddings in Qdrant).

This illustrates how AI adds semantic context to customer data within a cloud-native CRM.