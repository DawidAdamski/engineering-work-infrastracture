# Qdrant

Qdrant is a **vector database** used for storing and retrieving customer embeddings generated by the n8n workflow.  
It enables **AI-based segmentation and similarity search** across CRM customers.

---

## Purpose

- Store numerical embeddings representing customer profiles.  
- Support similarity queries (find customers with comparable purchase behaviors).  
- Serve as the **AI-driven extension** to classical RFM segmentation.  
- Integrate seamlessly with PostgreSQL and CRM API inside Kubernetes.

---

## Deployment Overview

|Item|Value|
|:--|:--|
|**Namespace**|`crm-rfm`|
|**Service name**|`qdrant`|
|**Port**|`6333`|
|**Persistence**|PVC mounted to `/qdrant/storage`|
|**Access**|LoadBalancer (with MetalLB) or NodePort|

Internal DNS for in-cluster communication:
qdrant.crm-rfm.svc.cluster.local:6333


Qdrant runs as a **Deployment** or **StatefulSet** depending on storage configuration.  
Data is persisted using a PersistentVolumeClaim (PVC).

---

## Collection Design

|Parameter|Example|
|:--|:--|
|**Collection name**|`customers`|
|**Vector size**|`1536` (for `text-embedding-3-large` model)|
|**Distance metric**|`Cosine`|
|**Payload fields**|`customer_id`, `created_at`, `segment`, `rfm_score`|

The **n8n workflow** automatically ensures that the collection exists before inserting data.

Example initialization request (via HTTP API):

```json
PUT /collections/customers
{
  "vectors": {
    "size": 1536,
    "distance": "Cosine"
  }
}
```

---

## Typical Data Flow

1. n8n fetches customers from PostgreSQL without embeddings.
2. n8n calls the OpenAI Embedding API to generate a vector.
3. n8n sends the vector and metadata to Qdrant:

```json
POST /collections/customers/points
{
  "points": [
    {
      "id": 123,
      "vector": [0.011, 0.092, -0.034, ...],
      "payload": {
        "customer_id": 123,
        "rfm_recency": 45,
        "rfm_frequency": 5,
        "rfm_monetary": 1200.5
      }
    }
  ]
}
```

4. Qdrant indexes and stores the point, making it available for similarity search.

---

## Querying Similar Customers

**n8n workflows** query Qdrant to find customers with similar embeddings (on behalf of CRM API):

```json
POST /collections/customers/points/search
{
  "vector": [0.011, 0.092, -0.034, ...],
  "limit": 5,
  "with_payload": true
}
```

Response example:

```json
{
  "result": [
    { "id": 789, "score": 0.91, "payload": { "customer_id": 789 } },
    { "id": 654, "score": 0.87, "payload": { "customer_id": 654 } }
  ]
}
```

**Note:** CRM API does not query Qdrant directly. Instead:
1. CRM API receives a similarity search request
2. CRM API calls an n8n webhook/API endpoint
3. n8n workflow queries Qdrant and returns results
4. CRM API formats and returns the response to the client

---

## Integration with Other Components

| Component | Interaction |
|:--|:--|
| n8n workflow | Creates or updates points in Qdrant using embeddings from OpenAI. Also handles similarity queries on behalf of CRM API. |
| CRM API | **Does not connect directly to Qdrant.** Instead, CRM API calls n8n workflows which query Qdrant for similarity search. |
| PostgreSQL | Indirect relationship — Qdrant stores references to PostgreSQL customer IDs. |

---

## Configuration Variables

| Variable | Purpose |
|:--|:--|
| `QDRANT_URL` | Internal URL for the service (default: `http://qdrant.crm-rfm.svc.cluster.local:6333`) |
| `QDRANT_COLLECTION` | Collection name used by n8n and CRM API (`customers`) |
| `QDRANT_API_KEY` | Optional — if authentication is enabled |

---

## Persistence Notes

- Use a PVC to persist vectors between Pod restarts.
- Default path: `/qdrant/storage` inside the container.
- Storage requirements grow with dataset size and vector dimension.
- For development in Minikube, a PVC volume is sufficient.

---

## Accessing Qdrant

Qdrant provides a **web UI** and **REST API** for managing collections and querying vectors. There are several ways to access it:

### Method 1: LoadBalancer (External IP)

If Qdrant is deployed as a **LoadBalancer** service (with MetalLB), it will have an external IP:

```bash
# Check the external IP
kubectl get svc qdrant -n crm-rfm

# Example output:
# NAME     TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)
# qdrant   LoadBalancer   10.99.183.220   192.168.0.202   6333:31746/TCP,6334:30812/TCP
```

**Access Qdrant:**
- **Web UI:** `http://<EXTERNAL-IP>:6333/dashboard`
- **REST API:** `http://<EXTERNAL-IP>:6333`
- **gRPC:** `<EXTERNAL-IP>:6334`

**Example:**
```bash
# Open Qdrant dashboard in browser
open http://192.168.0.202:6333/dashboard

# Or access via curl
curl http://192.168.0.202:6333/collections
```

### Method 2: Port-Forward (Local Access)

Forward the Qdrant port to your local machine:

```bash
# Port-forward Qdrant service
kubectl port-forward svc/qdrant 6333:6333 -n crm-rfm
```

Then access:
- **Web UI:** `http://localhost:6333/dashboard`
- **REST API:** `http://localhost:6333`

**Note:** Keep the port-forward terminal session running while you use the connection.

### Method 3: NodePort (Direct External Access)

If Qdrant is exposed as a **NodePort** service:

```bash
# Get Minikube IP
minikube ip

# Access Qdrant (replace <minikube-ip> with actual IP)
open http://$(minikube ip):30333/dashboard
curl http://$(minikube ip):30333/collections
```

### Method 4: From Within Kubernetes Cluster

Applications running inside the cluster can connect using the internal DNS:

**REST API URL:**
```
http://qdrant.crm-rfm.svc.cluster.local:6333
```

**gRPC URL:**
```
qdrant.crm-rfm.svc.cluster.local:6334
```

**Environment variables:**
- `QDRANT_URL=http://qdrant.crm-rfm.svc.cluster.local:6333`
- `QDRANT_GRPC_URL=qdrant.crm-rfm.svc.cluster.local:6334`

### Qdrant Web Dashboard

Qdrant provides a built-in web dashboard for:
- Viewing collections
- Browsing points/vectors
- Testing queries
- Monitoring cluster status

**Access the dashboard:**
- Via LoadBalancer: `http://<EXTERNAL-IP>:6333/dashboard`
- Via Port-Forward: `http://localhost:6333/dashboard`
- Via NodePort: `http://$(minikube ip):30333/dashboard`

### Common API Endpoints

```bash
# List all collections
curl http://<qdrant-url>/collections

# Get collection info
curl http://<qdrant-url>/collections/customers

# Search for similar vectors
curl -X POST http://<qdrant-url>/collections/customers/points/search \
  -H "Content-Type: application/json" \
  -d '{
    "vector": [0.1, 0.2, 0.3, ...],
    "limit": 5
  }'
```

---

## Security & Access

- Default deployment exposes port `6333` (HTTP REST API) and `6334` (gRPC).
- Qdrant web dashboard is available at `/dashboard` endpoint.
- For production, consider enabling authentication via `QDRANT_API_KEY`.
- Limit external exposure — Qdrant can remain an internal ClusterIP service if only accessed from within the cluster.
- Secure credentials and configuration using Kubernetes Secrets or ConfigMaps.

---

## Example Use Case in Thesis

In the engineering work, Qdrant serves as the AI-based segmentation engine, allowing comparison between:

- Traditional SQL-driven segmentation (RFM table in PostgreSQL), and
- AI-driven similarity search (vector embeddings in Qdrant).

This illustrates how AI adds semantic context to customer data within a cloud-native CRM.